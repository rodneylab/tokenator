use std::path::PathBuf;

use clap_verbosity_flag::Verbosity;

/// Command-line interface configuration.
///
/// This struct is generated by `clap` and includes all command-line options and flags defined in
/// this module.
#[derive(clap::Parser)]
#[clap(author,version,about,long_about=None)]
pub struct Cli {
    /// Verbosity level (-v for warnings, -vv for info, -vvv for debug, -vvvv for trace)
    #[clap(flatten)]
    pub verbose: Verbosity,

    /// Optional file to use as a prompt
    #[clap(short, long, value_parser)]
    pub file: Option<PathBuf>,

    /// LLM model to count tokens for
    #[clap(short, long, value_parser)]
    pub model: Option<String>,

    /// Prompt
    pub prompt: Option<String>,
}

#[cfg(test)]
mod tests {
    use std::ffi::OsString;

    use clap::Parser;

    use crate::cli::Cli;

    /// Parses CLI arguments and returns a `Cli` instance.
    fn parse_args<I, T>(args: I) -> Cli
    where
        I: IntoIterator<Item = T>,
        T: Into<OsString> + Clone,
    {
        Cli::try_parse_from(args).unwrap()
    }

    #[test]
    fn test_no_arguments() {
        // arrange
        let args = vec!["program"];

        // act
        let cli = parse_args(&args);

        // assert
        assert_eq!(cli.verbose.log_level(), Some(log::Level::Error));
    }

    #[test]
    fn test_verbosity_flag() {
        // arrange
        let args = vec!["program", "-v"];

        // act
        let cli = parse_args(&args);

        // assert
        assert_eq!(cli.verbose.log_level(), Some(log::Level::Warn));
    }

    #[test]
    fn test_verbose_flag_multiple_times() {
        // arrange
        let args = vec!["program", "-vv"];

        // act
        let cli = parse_args(&args);

        // assert
        assert_eq!(cli.verbose.log_level(), Some(log::Level::Info));
    }
}
